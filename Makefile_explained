
# define C compiler & flags
CC = gcc
CFLAGS = -Wall
# just like #define in C, here:
#    CC becomes a symbolic name, and is equivalent to "gcc"
#    CFLAGS is equivalent to "-Wall"

# define libraries to be linked (for example -lm)
LIB = 
#   LIB is equivalent to "" (empty), 
#   if we want to compile with "-lm" we should write:
#   LIB = -lm

HDR = intArray.h search.h
SRC1 = intArray.c main.c seq_search.c
SRC2 = intArray.c main.c bin_search.c
# HDR, SRC1, SRC2 are symbolic names,
# each of them is a string containing several file names
#    HDR contains all .h files, needed for both search modules
#    SRC1 contains all .c files for the sequential search module
#    SRC2 contains all .c files for the binary search module


# OBJ? is the same as SRC?, just sustitute ".c" with ".o"
OBJ1     = $(SRC1:.c=.o)
OBJ2     = $(SRC2:.c=.o)
# so, OBJ1 becomes "intArray.o main.o seq_search.o
# recall that "intArray.o" stands for the object file
# translated by "gcc" from "intArray.c", ie. it is the product of command:
#     gcc -c intArray.c

# the executable name
EXE1 = seq_search
EXE2 = bin_search
# Here we have 2 executable files: seq_search and bin_search


all: $(EXE1) $(EXE2)
# "all" is the first target
# and "all" depends on seq_search and bin_search
# hence, "make all" will be equivalent to:
#    make seq_search
#    make bin_search 

$(EXE1): $(HDR) $(OBJ1) Makefile
	$(CC) $(CFLAGS) -o $(EXE1) $(OBJ1) $(LIB)
# so, seq_search (ie EXE1) depends on 
#   intArray.h search.h intArray.o main.o seq_search.o
# and is associated with command:
#   gcc -Wall -o seq_search intArray.o main.o seq_search.o
# Note that we don't actually have intArray.o
# Whenever "make" see a dependency "somename.o" it automatically
#   generate a target:
#somename.o: somename.c
#    gcc -c somename.c
#That means, before running the above "gcc", "make" will  execute:
#   gcc -c intArray.c
#   gcc -c main.c
#   gcc -c seq_search.c
#in order to create the needed intArray.o, main.o, and seq_search.o    


$(EXE2): $(HDR) $(OBJ2) Makefile
	echo $(OBJ2)
	$(CC) $(CFLAGS) -o $(EXE2) $(OBJ2) $(LIB)


clean: 
	rm -f $(OBJ1) $(OBJ2) $(EXE1) $(EXE2)
# The target "clean" helps to remove all files "make" created, include
#     all `.o` files ( which are in OBJ1 and OBJ2 ) 
#     end the files seq_search, binary_search (in EXE1 and EXE). 
# The purpose running "make clean" is:
#   - for you to be able to recompile the project 
#     (for example, after copying the project to a different computers)
#   - to clean the non-essential files so that you can economically
#     copy the whole project to an archive.
 

$(OBJ1): $(HDR)
$(OBJ2): $(HDR)
# The two last lines just state the dependencies for the objects .o files
# It means that when one of the file in the list HDR changed,
# "make" must rebuild the .o files (ie. recompile them).
 
